module Unification exposing
    ( History
    , unifyStepByStep
    , viewHistoryEntry
    )

import Dict exposing (Dict)
import LambdaTypes exposing (Constraint, Type(..), TypeVariable, viewConstraints, viewType)
import Html exposing (Html, table, tr, td, text, div)
import Html.Attributes exposing (class, classList)

type alias History = Dict Int HistoryEntry

type alias HistoryEntry =
    -- TODO: refactor this into its own sum type
    -- This is an kinda okay type because
    -- * Only one substitution is ever generated by a single unification step (?)
    -- * New substitutions are always added at the "beginning" of the unifier
    Result (Type, Type, List Constraint)
        { constraints : List Constraint
        , newSubstitution : Maybe Substitution
        , substitutions : List Substitution
        }

type alias Substitution =
    { replace : TypeVariable
    , by : Type
    }

unifyStepByStep : List Constraint -> History
unifyStepByStep =
    let
        unifyStepByStepAcc : List Substitution -> List Constraint -> List HistoryEntry
        unifyStepByStepAcc subs constraints =
            case constraints of
                [] ->
                    [ Ok { constraints = [], newSubstitution = Nothing, substitutions = subs } ]
                nonEmpty ->
                    case unifyStep constraints of
                        Err (lhs, rhs) ->
                            [ Err (lhs, rhs, constraints) ]
                        Ok (remainingConstraints, newSubst) ->
                            [ Ok { constraints = constraints, newSubstitution = newSubst, substitutions = subs } ] ++ unifyStepByStepAcc (maybeToList newSubst ++ subs) remainingConstraints
                        

        maybeToList m =
            case m of
                Just x -> [x]
                Nothing -> []
    in
        Dict.fromList << List.indexedMap Tuple.pair << unifyStepByStepAcc []
        

unifyStep : List Constraint -> Result (Type, Type) (List Constraint, Maybe Substitution)
unifyStep constraints =
    let
        -- stupid hack that is necessary because Elms pattern matching lacks guards
        -- TODO: forum/reddit, clean up this mess
        unifyLeftRightRest : Type -> Type -> List Constraint -> Result (Type, Type) (List Constraint, Maybe Substitution)
        unifyLeftRightRest lhs rhs rest =
            let
                lhsEqualsRhs =
                    if lhs == rhs then
                        Just (rest, Nothing)
                    else
                        Nothing

                varAndOccursCheck a b =
                    case a of
                        TypeVar tv -> 
                            if not <| List.member tv <| LambdaTypes.fv b then
                                -- TODO: apply new subst
                                Just (List.map (apply <| Substitution tv b) rest, Just <| Substitution tv b)
                            else
                                Nothing
                        _ ->
                            Nothing

                -- TODO: this is also ugly, could be prettier
                apply : Substitution -> Constraint -> Constraint
                apply s c =
                    let
                        apply_ { replace, by } x =
                            case x of
                                TypeVar tv ->
                                    if tv == replace then
                                        by
                                    else
                                        x
                                _ ->
                                    x
                    in
                        { lhs = apply_ s c.lhs
                        , rhs = apply_ s c.rhs
                        }

                -- make function of a and b for "laziness" ~> better perf?
                functionTypes =
                    case (lhs, rhs) of
                        (FunctionType f1 x1, FunctionType f2 x2) ->
                            Just (rest ++ [ Constraint f1 f2, Constraint x1 x2 ], Nothing)
                        _ ->
                            Nothing
                
                -- TODO: doc
                orMaybe : Maybe a -> Maybe a -> Maybe a
                orMaybe m1 m2 =
                    -- TODO: Is `if` needed here for laziness?
                    -- Is `case` sufficient?
                    if m2 /= Nothing then
                        m2
                    else
                        m1
            in
            lhsEqualsRhs
            |> orMaybe (varAndOccursCheck lhs rhs)
            |> orMaybe (varAndOccursCheck rhs lhs)
            |> orMaybe functionTypes
            |> Result.fromMaybe (lhs, rhs)
    in
    case constraints of
        [] -> Ok ([], Nothing)
        ({ lhs, rhs } :: rest) -> unifyLeftRightRest lhs rhs rest

viewHistoryEntry : HistoryEntry -> List (Html a)
viewHistoryEntry entry =
    let
        constraints =
            case entry of
                Ok e -> e.constraints
                Err (_, _, c) -> c

        viewSubstitutionsOrErrorMsg =
            case entry of
                Err (lhs, rhs, _) ->
                    div []
                        [ viewType lhs
                        , text " is not unifiable with "
                        , viewType rhs
                        ]
                Ok { substitutions, newSubstitution } ->
                    table [ class "substitutions" ] <|
                        case (newSubstitution, substitutions) of
                            (Just first, rest) ->
                                [ viewSubstitution "[" True first ] ++ List.map (viewSubstitution "," False) rest ++ [ emptyRow "]" ]
                            (Nothing, first :: rest) ->
                                [ viewSubstitution "[" False first ] ++ List.map (viewSubstitution "," False) rest ++ [ emptyRow "]" ]
                            (Nothing, []) ->
                                -- shouldn't ever need to be display, first constraint is never "func = func"
                                [ emptyRow "[" ] ++ [ emptyRow "]" ]
         
        viewSubstitution symbol isNew { replace, by } =
            tr [ classList [ ("substitution", True), ("-new", isNew) ] ]
                [ td [ class "substitution-lead" ] [ text symbol ]
                , td [ class "substitution-lhs" ] [ viewType <| TypeVar replace ]
                , td [ class "substitution-arrow" ] [ text "â‡¨" ]
                , td [ class "substitution-rhs" ] [ viewType by ]
                ]
        
        emptyRow symbol =
            tr [ class "substitution" ]
                [ td [ class "substitution-lead" ] [ text symbol ]
                , td [ class "substitution-lhs" ] []
                , td [ class "substitution-arrow" ] []
                , td [ class "substitution-rhs" ] []
                ]

    in
        [ viewConstraints constraints
        , viewSubstitutionsOrErrorMsg
        ]
