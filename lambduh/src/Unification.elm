module Unification exposing
    ( History
    , unifyStepByStep
    , viewHistoryEntry
    )

import Dict exposing (Dict)
import LambdaTypes exposing (Constraint, Type(..), TypeVariable, viewConstraints, viewType)
import Html exposing (Html, table, tr, td, text)
import Html.Attributes exposing (class, classList)

type alias History = Dict Int HistoryEntry

type alias HistoryEntry =
    -- This is an kinda okay type because
    -- * Only one substitution is ever generated by a single unification step (?)
    -- * New substitutions are always added at the "beginning" of the unifier
    { constraints : List Constraint
    , newSubstitution : Maybe Substitution
    , substitutions : List Substitution
    }

type alias Substitution =
    { replace : TypeVariable
    , by : Type
    }

unifyStepByStep : List Constraint -> History
unifyStepByStep =
    let
        unifyStepByStepAcc : List Substitution -> List Constraint -> List HistoryEntry
        unifyStepByStepAcc subs constraints =
            case constraints of
                [] ->
                    [ HistoryEntry [] Nothing subs ]
                nonEmpty ->
                    let
                        -- TODO
                        -- This withDefault should a) be replaced by something useful
                        -- And b) at least contain a Debug.todo, but that's strict :(
                        -- TODO: should be handled by generating an "error" historyentry that shows the message
                        (remainingConstraints, newSubst) = Maybe.withDefault ([], Nothing) <| Result.toMaybe <| unifyStep constraints
                    in
                        [ HistoryEntry constraints newSubst subs ] ++ unifyStepByStepAcc (maybeToList newSubst ++ subs) remainingConstraints

        maybeToList m =
            case m of
                Just x -> [x]
                Nothing -> []
    in
        Dict.fromList << List.indexedMap Tuple.pair << unifyStepByStepAcc []
        

unifyStep : List Constraint -> Result (Type, Type) (List Constraint, Maybe Substitution)
unifyStep constraints =
    let
        -- stupid hack that is necessary because Elms pattern matching lacks guards
        -- TODO: forum/reddit, clean up this mess
        unifyLeftRightRest : Type -> Type -> List Constraint -> Result (Type, Type) (List Constraint, Maybe Substitution)
        unifyLeftRightRest lhs rhs rest =
            let
                lhsEqualsRhs =
                    if lhs == rhs then
                        Just (rest, Nothing)
                    else
                        Nothing

                varAndOccursCheck a b =
                    case a of
                        TypeVar tv -> 
                            if not <| List.member tv <| LambdaTypes.fv b then
                                -- TODO: apply new subst
                                Just (List.map (apply <| Substitution tv b) rest, Just <| Substitution tv b)
                            else
                                Nothing
                        _ ->
                            Nothing

                -- TODO: this is also ugly, could be prettier
                apply : Substitution -> Constraint -> Constraint
                apply s c =
                    let
                        apply_ { replace, by } x =
                            case x of
                                TypeVar tv ->
                                    if tv == replace then
                                        by
                                    else
                                        x
                                _ ->
                                    x
                    in
                        { lhs = apply_ s c.lhs
                        , rhs = apply_ s c.rhs
                        }

                -- make function of a and b for "laziness" ~> better perf?
                functionTypes =
                    case (lhs, rhs) of
                        (FunctionType f1 x1, FunctionType f2 x2) ->
                            Just (rest ++ [ Constraint f1 f2, Constraint x1 x2 ], Nothing)
                        _ ->
                            Nothing
                
                -- TODO: doc
                orMaybe : Maybe a -> Maybe a -> Maybe a
                orMaybe m1 m2 =
                    -- TODO: Is `if` needed here for laziness?
                    -- Is `case` sufficient?
                    if m2 /= Nothing then
                        m2
                    else
                        m1
            in
            lhsEqualsRhs
            |> orMaybe (varAndOccursCheck lhs rhs)
            |> orMaybe (varAndOccursCheck rhs lhs)
            |> orMaybe functionTypes
            |> Result.fromMaybe (lhs, rhs)
    in
    case constraints of
        [] -> Ok ([], Nothing)
        ({ lhs, rhs } :: rest) -> unifyLeftRightRest lhs rhs rest

viewHistoryEntry : HistoryEntry -> List (Html a)
viewHistoryEntry { constraints, newSubstitution, substitutions } =
    let
        viewSubstitutions =
            case (newSubstitution, substitutions) of
                (Just first, rest) ->
                    [ viewSubstitution "[" True first ] ++ List.map (viewSubstitution "," False) rest ++ [ emptyRow "]" ]
                (Nothing, first :: rest) ->
                    [ viewSubstitution "[" False first ] ++ List.map (viewSubstitution "," False) rest ++ [ emptyRow "]" ]
                (Nothing, []) ->
                    -- shouldn't ever need to be display, first constraint is never "func = func"
                    [ emptyRow "[" ] ++ [ emptyRow "]" ]
         
        viewSubstitution symbol isNew { replace, by } =
            tr [ classList [ ("substitution", True), ("-new", isNew) ] ]
                [ td [ class "substitution-lead" ] [ text symbol ]
                , td [ class "substitution-lhs" ] [ viewType <| TypeVar replace ]
                , td [ class "substitution-arrow" ] [ text "â‡¨" ]
                , td [ class "substitution-rhs" ] [ viewType by ]
                ]
        
        emptyRow symbol =
            tr [ class "substitution" ]
                [ td [ class "substitution-lead" ] [ text symbol ]
                , td [ class "substitution-lhs" ] []
                , td [ class "substitution-arrow" ] []
                , td [ class "substitution-rhs" ] []
                ]
    in
        [ viewConstraints constraints
        , table [ class "substitutions" ] viewSubstitutions
        ]
