module Unification exposing
    ( History
    , unifyStepByStep
    )

import LambdaTypes exposing (Constraint, Type(..), TypeVariable)

type alias History = List HistoryEntry

type alias HistoryEntry =
    -- This is an kinda okay type because
    -- * Only one substitution is ever generated by a single unification step (?)
    -- * New substitutions are always added at the "beginning" of the unifier
    { constraints : List Constraint
    , newSubstitution : Maybe Substitution
    , substitutions : List Substitution
    }

type alias Substitution =
    { replace : TypeVariable
    , by : Type
    }

unifyStepByStep : List Constraint -> History
unifyStepByStep =
    let
        unifyStepByStepAcc : List Substitution -> List Constraint -> History
        unifyStepByStepAcc subs constraints =
            case constraints of
                [] ->
                    [ HistoryEntry [] Nothing subs ]
                nonEmpty ->
                    let
                        -- TODO
                        -- This withDefault should a) be replaced by something useful
                        -- And b) at least contain a Debug.todo, but that's strict :(
                        -- TODO: should be handled by generating an "error" historyentry that shows the message
                        (remainingConstraints, newSubst) = Maybe.withDefault ([], Nothing) <| Result.toMaybe <| unifyStep constraints
                    in
                        [ HistoryEntry constraints newSubst subs ] ++ unifyStepByStepAcc (subs ++ maybeToList newSubst) remainingConstraints

        maybeToList m =
            case m of
                Just x -> [x]
                Nothing -> []
    in
        unifyStepByStepAcc []
        

unifyStep : List Constraint -> Result (Type, Type) (List Constraint, Maybe Substitution)
unifyStep constraints =
    let
        -- stupid hack that is necessary because Elms pattern matching lacks guards
        -- TODO: forum/reddit, clean up this mess
        unifyLeftRightRest : Type -> Type -> List Constraint -> Result (Type, Type) (List Constraint, Maybe Substitution)
        unifyLeftRightRest lhs rhs rest =
            let
                lhsEqualsRhs =
                    if lhs == rhs then
                        Just (rest, Nothing)
                    else
                        Nothing

                varAndOccursCheck a b =
                    case a of
                        TypeVar tv -> 
                            if not <| List.member tv <| LambdaTypes.fv b then
                                -- TODO: apply new subst
                                Just (List.map (apply <| Substitution tv b) rest, Just <| Substitution tv b)
                            else
                                Nothing
                        _ ->
                            Nothing

                -- TODO: this is also ugly, could be prettier
                apply : Substitution -> Constraint -> Constraint
                apply s c =
                    let
                        apply_ { replace, by } x =
                            case x of
                                TypeVar tv ->
                                    if tv == replace then
                                        by
                                    else
                                        x
                                _ ->
                                    x
                    in
                        { lhs = apply_ s c.lhs
                        , rhs = apply_ s c.rhs
                        }

                -- make function of a and b for "laziness" ~> better perf?
                functionTypes =
                    case (lhs, rhs) of
                        (FunctionType f1 x1, FunctionType f2 x2) ->
                            Just (rest ++ [ Constraint f1 f2, Constraint x1 x2 ], Nothing)
                        _ ->
                            Nothing
                
                -- TODO: doc
                orMaybe : Maybe a -> Maybe a -> Maybe a
                orMaybe m1 m2 =
                    -- TODO: Is `if` needed here for laziness?
                    -- Is `case` sufficient?
                    if m2 /= Nothing then
                        m2
                    else
                        m1
            in
            lhsEqualsRhs
            |> orMaybe (varAndOccursCheck lhs rhs)
            |> orMaybe (varAndOccursCheck rhs lhs)
            |> orMaybe functionTypes
            |> Result.fromMaybe (lhs, rhs)
    in
    case constraints of
        [] -> Ok ([], Nothing)
        ({ lhs, rhs } :: rest) -> unifyLeftRightRest lhs rhs rest
